#!/usr/bin/env python2.7

# oci-utils
#
# Copyright (c) 2017, 2018 Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at http://oss.oracle.com/licenses/upl.

'''
This utility displays instance metadata when run on Oracle Cloud Infrastructure
instances.  See the manual page for more information.
'''
import os
import sys
import argparse
import logging
import time
import collections
try:
    import json
except ImportError:
    import simplejson as json

import oci_utils.metadata
from oci_utils.metadata import get_by_path, get_path_keys
from oci_utils.oci_api import OCIInstance 

oci_metadata_detail = {
    'displayName': 'Display Name',
    'hostnameLabel': 'Hostname Label',
    'timeCreated': 'Created at',
    'image': 'Image ID',
    'lifecycleState': 'Lifecycle State',
    'shape': 'Instance shape',
    'region': 'Region',
    'availabilityDomain': 'Availability Domain',
    'compartmentId': 'Compartment OCID',
    'id': 'OCID',
    'macAddr': 'MAC address',
    'subnetCidrBlock': 'Subnet CIDR block',
    'subnetId': 'Subnet ID',
    'vnicId': 'VNIC OCID',
    'privateIp': 'Private IP address',
    'publicIp': 'Public IP address',
    'faultDomain': 'Fault domain',
    'virtualRouterIp': 'Virtual router IP address',
    'vlanTag': 'VLAN Tag',
    'nicIndex': 'NIC Index',
    'metadata': 'Metadata', 
    'definedTags': 'Defined Tags',
    'freeformTags': 'Freeform Tags',
    'extendedMetadata': 'Extended Metadata',
    'launchMode': 'Launch Mode',
    'ipxeScript': 'iPXE Script',
    'sourceDetails': 'Source Details',
    'launchOptions': 'Launch Options',
    'skipSourceDestCheck':'Skip Source/Dest Check',
    'canonicalRegionName':'Canonical Region Name',
    }
lower_metadata_fields = {key.lower():key for key in oci_metadata_detail}

oci_regions = {
    'phx': 'phx - us-phoenix-1 (Phoenix, AZ, USA)',
    'iad': 'iad - us-ashburn-1 (Ashburn, VA, USA)',
    'fra': 'fra - eu-frankfurt-1 (Frankfurt, Germany)',
    'lhr': 'lhr - uk-london-1 (London, UK)'
    }

oci_metadata_display_order = [
    'displayName', 'region', 'canonicalRegionName', 'availabilityDomain', 'faultDomain',
    'id', 'compartmentId', 'shape', 'image','timeCreated', 'state',
    'vnicId', 'vlanTag','nicIndex'
    'privateIp', 'publicIp','macAddr', 'subnetCidrBlock', 'virtualRouterIp',
    ]

human_readable_type = {
        str: 'string type',
        dict: 'json format'
    }

oci_metadata_ignores = [
    'definedTags',
    'freeformTags',
    'launchMode',
    'ipxeScript',
    'sourceDetails',
    'launchOptions',
    'skipSourceDestCheck',
    'canonicalRegionName',
    ]

# exportable keys
exportable_keys = [ "metadata", "extendedMetadata" ]

def parse_args():
    '''
    Parse the command line arguments and return an object representing the
    command line (as returned by argparse's parse_args())
    '''
    parser = argparse.ArgumentParser(description='Utility for displaying '
                                     'metadata for an instance running in '
                                     'the Oracle Cloud Infrastructure.',
                                     add_help=False)
    parser.add_argument('-h', '--human-readable', action='store_true',
                        help='Display human readable output (default)')
    parser.add_argument('-j', '--json', action='store_true',
                        help='Display json output')
    parser.add_argument('-g', '--get', metavar='KEY', dest='keys',
                        action='append', type=str.lower,
                        help='Display the value of a specific key. '
                        'Key can be any single field-name in metadata json output,'
                        'or a path like /instance/id, or /vnics/*/vnicid')
    parser.add_argument('--value-only', action='store_true',
                        help='Used with one -g option, return a list of values matching the key.')
    parser.add_argument('--export', action='store_true',
                        help='Used with the -g option, export the keys as environment variables.')
    parser.add_argument('--trim', action='store_true',
                        help='Used with the -g option, trim the key path to the last component.')
    parser.add_argument('-u', '--update', nargs='+', metavar='KEY=VALUE ', dest='setkeys',
                        action='append', type=str,
                        help='Update the value for a specific key.  KEY can be displayName or a key in the extended metadata.'
                        ' VALUE can be a string, JSON data or a pointer to a file containing JSON data.'
                        ' Note: do not put spaces around "=".'
                        )
    parser.add_argument('-i', '--instance-id', metavar='OCID',
                        action='store', type=str,
                        help='get or set metadata for the specified instance')
    parser.add_argument('--debug', action='store_true',
                        help=argparse.SUPPRESS)
    parser.add_argument('--help', action='help',
                        help='Display this help')

    args = parser.parse_args()
    return args


def pretty_print_section(metadata, indent):
    """
    Display a section of the metadata, indented by the given indent string
    """
    # first display the keys that are in the oci_metadata_display_order list
    if type(metadata) is not dict:
        for element in list(metadata):
            if type(element) is dict:
                pretty_print_section(element, indent + "  " )
            else:
                #if type(element) is str: 
                print "%s%s" % (indent, element)
    for key in oci_metadata_display_order:
        if key not in metadata:
            continue

        display_key = key
        if key in oci_metadata_detail:
            display_key = oci_metadata_detail[key]
        value = metadata[key]
        
        if type(metadata[key]) is dict:
            print "%s%s:" % (indent, display_key) 
            pretty_print_section(value, indent + "  ")
            continue

        if key == 'region':
            if value in oci_regions:
                value = oci_regions[value]
        elif key == 'timeCreated':
           # value = time.strftime('%Y-%m-%d %H:%M:%S UTC',
           #                       time.gmtime(metadata['timeCreated']/1000))
           pass
        print "%s%s: %s" % (indent, display_key, value)

    for key in metadata:
        # already printed the ones in oci_metadata_display_order
        if key in oci_metadata_display_order:
            continue
        if key in oci_metadata_ignores:
            continue
        # print it last unless it's listed in oci_metadata_display_order
        if key == 'metadata':
            continue
        display_key = key
        if key in oci_metadata_detail:
            display_key = oci_metadata_detail[key]

        value = metadata[key]

        if type(metadata[key]) is dict:
            print "%s%s:" % (indent, display_key) 
            pretty_print_section(value, indent + "  ")
            continue

        print "%s%s: %s" % (indent, display_key, value)

    # print it last unless it's listed in oci_metadata_display_order
    if 'metadata'  in metadata and 'metadata' not in oci_metadata_display_order:
        print "%sInstance Metadata:" % indent
        pretty_print_section(metadata['metadata'], indent + "  ")

def pretty_print(metadata):
    if 'instance' in metadata:
        print "Instance details:"
        pretty_print_section(metadata['instance'], '  ')


    if 'publicIp' in metadata or 'vnics' in metadata:
        print "Networking details:"

        if 'publicIp' in metadata:
            print "  Public IP address: %s" % metadata['publicIp']

        if 'vnics' in metadata:
            if len(metadata['vnics']) > 1:
                if_num = 1
                for vnic_data in metadata['vnics']:
                    print "  VNIC %s:" % if_num
                    pretty_print_section(vnic_data, '    ')
                    if_num += 1
            else:
                pretty_print_section(metadata['vnics'][0], '  ')

    elif 'instance' not in metadata: 
        #None of the previous sections.
        pretty_print_section(metadata, '')

def dumper(obj):
    try:
        return obj.toJSON()
    except: 
        try:
            return obj.__dict__()
        except:
            return obj.__str__()


def parse_var(keyValue):
    '''
    parse a key, value pair, seperated by "="
    :param keyValue: "key=value"
    :return: key, value
    '''
    items = keyValue.split('=')
    key = items[0].strip()
    if len(items) >1:
        value='='.join(items[1:])
        if len(value)==0:
             sys.stderr.write("Warning: Value is empty.\n")

        if value.startswith("{"):
            json_acceptable_string = value.replace("'", "\"") 
            try:
                tmp = json.loads(json_acceptable_string)
                value = tmp
            except Exception as e:
                sys.stderr.write("Invalid value '%s': %s\n" % (value, e))
                sys.exit(1)


        elif value.startswith("file:"):
            try:
                fname = value[5:]
                if os.path.isfile(fname):
                    fp = open(fname,'r')
                    d=json.loads(fp.read().replace("'", "\""))
                    value = d
                    fp.close()
                else:
                    sys.stderr.write("Invalid file path: %s\n" % fname)
                    sys.exit(1)
            except Exception as e:
                sys.stderr.write("Invalid file content (%s): %s\n" % (fname, e))
                sys.exit(1)
    else:
        sys.stderr.write("Error: -u or --update expects key='value' format, not %s\n" % keyValue)
        sys.exit(1)

    return (key, value)

def parse_vars(items):
    '''
    parse a series of key-value pairs and return a dictionary.
    '''
    d = {}
    if items:
        for item_list in items:
            for item in item_list:
                key, value = parse_var(item)
                if key.find('/') >= 0:
                    sys.stderr.write("Key should be simple without path (%s)\n" % (key))
                    sys.exit(1)
                d[key] = value
    return d

def verify_setkeys(set_keys):
    '''
    Verify the key, value pair according to the OCIInstance.settable_field_type
    '''
    if set_keys is None:
        sys.stderr.write("You must provide a key=value for update option.\n")
        return False
    keys = set_keys.keys()
    for k in keys:
        if k in OCIInstance.settable_field_type:
            v = set_keys[k]
            if v is None or  type(v) is OCIInstance.settable_field_type[k]:
                continue
            else:
                sys.stderr.write("Error: key %s expects value of %s, not %s.\n" % (k, human_readable_type[OCIInstance.settable_field_type[k]], human_readable_type[type(v)]))
                return False
        elif k.lower() in OCIInstance.lower_settable_fields:
            v = set_keys.pop(k)
            k = OCIInstance.lower_settable_fields.get(k.lower())
            if v is None or type(v) is OCIInstance.settable_field_type[k]:
                set_keys[k] = v
            else:
                sys.stderr.write("Error: key %s expects value of %s, not %s.\n" % (k, human_readable_type[OCIInstance.settable_field_type[k]], human_readable_type[type(v)]))
                return False

        elif k.lower() in lower_metadata_fields or k.lower() in oci_utils.metadata.attribute_map:
            sys.stderr.write("Error: key(%s) is one of the reserved names.\n" % k)
            return False
        else:
            if "extendedMetadata" in set_keys.keys():
                extended_metadata = set_keys[ "extendedMetadata"]
            else:
                extended_metadata = {}

            extended_metadata[k] = set_keys[k]
            set_keys['extendedMetadata'] = extended_metadata
    return True

def get_values(key, metadata):
    """
       return a list of all the values matching the key
    """
    if type(metadata) is list:
        if key.isdigit():
            return metadata[int(k)]
        values = []
        for i in range(len(metadata)):
            v = get_values(key, metadata[i])
            if type(v) is list:
                values.extend(v)
            elif v is not None:
                values.append(v)
        return values
    if type(metadata) is not dict:
        return None
    if key in metadata:
        return metadata[key]
    else:
        values = [] 
        for k in metadata:
            if key == k.lower():
                return metadata[k]
            v = get_values(key, metadata[k])
            if type(v) is list:
                values.extend(v)
            elif v is not None:
                values.append(v)
        return values 

def get_trimed_key_values(keys, metadata):
    """
    get the key trimmed in the metadata.
    
    Inputs:
    keys: a list of getting keys.
    metadata: a dict of matching values

    Returns:
    exportKeys: a new dict with trimed key and value.
    """

    metadata = convert_key_values_to_string(metadata)
    exportKeys = {}
    for key in keys:  
        ks = key.split('/')
        if len(ks[-1]) >0 :
            ke = ks[-1]
        else:
            ke = ks[-2]
        if ke in lower_metadata_fields:
            ke = lower_metadata_fields[ke]
        exportKeys[ke] = []
        if len(ks) > 1:
            #path key
            newkey_list = []
            get_path_keys(metadata,ks[1:], newkey_list)
            for key in newkey_list:
               v = get_by_path(metadata, key)
               if v:
                 exportKeys[ke].append(v)
            continue   
        v = get_values(ke,  metadata)
        if type(v) is list:
            exportKeys[ke].extend(v)
        elif v is not None:
            exportKeys[ke].append(v)
            
    remove_list_for_single_item_list(exportKeys)
    return exportKeys

def remove_list_for_single_item_list(dic):
    """
    If a key in the dictionary have a list value, which has 
    one or less item,  then the key 
    will be equal to the item in the list.

    Inputs:
    dic: a dictionary

    Returns:
    dic: the changed dictionary
    """
    for k,v in dic.iteritems():
        if type(v) is list: 
           if len(v) == 0:
               dict[k] = None
           elif len(v) == 1:
               dic[k] = v[0]
        
def print_trimed_key_values(keys, metadata):
    """
    print the trimmed key and its value.
    
    Inputs:
    keys: a list of getting keys.
    metadata: a dict of matching values

    Returns:
    None.
    """

    kValues = get_trimed_key_values(keys, metadata)
    for k,v in kValues.iteritems():
        if type(v) is list:
            for item in v:
                print k + ": " + str(item) 
        else:
            print k + ": " + str(v)

def print_value_only(keys, metadata):
    """
    print the values only for the matching key.
    
    Inputs:
    keys: a list of getting keys.
    metadata: a dict of matching values

    Returns:
    None.
    """

    kValues = get_trimed_key_values(keys, metadata)
    for k,v in kValues.iteritems():
        if type(v) is list:
            for item in v:
                print str(item) 
        else:
            print  str(v)


def export_keys(keys, metadata):
    """
    export the key and values in the metadata.
    
    Inputs:
    keys: a list of getting keys.
    metadata: a dict of matching values

    Returns:
    None.
    """

    kValues = get_trimed_key_values(keys, metadata)
    for k,v in kValues.iteritems():
        x = 'export '
        x += k + '=\"' 
        if type(v) is list:
            end = ""
            for item in v:
               x += end + str(item)
               end=" " 
        else:
            x += str(v)
        x += '\" '
        print x



def convert_key_values_to_string(d):
    """Recursively converts dictionary keys to strings."""
    if type(d) is unicode:
        return str(d)
    elif isinstance(d, collections.Mapping):
        nd = {} 
        for k, v in d.iteritems():
            nd[str(k)] = convert_key_values_to_string(v) 
        return nd 
    elif isinstance(d, collections.Iterable):
        return type(d)(convert_key_values_to_string(x) for x in d)
    else:
        return d

def main():
    '''
    Main program
    '''
    args = parse_args()

    metadata = None

    instId = None
    if args.instance_id:
	    instId = args.instance_id
    
    if args.export and not args.keys:
        sys.stderr.write("Error: --export only works with --get or -g.\n")
        return 1

    if args.trim and not args.keys:
        sys.stderr.write("Error: --trim only works with --get or -g. \n") 
        return 1

    if args.setkeys:
        if args.keys:
            sys.stderr.write("Error: -g or --get option conflicts with -u or --update. \n") 
            return 1

        k_v = parse_vars(args.setkeys)
        if not verify_setkeys(k_v):
            return 1
        try:
            meta = oci_utils.oci_api.OCISession().update_instance_metadata(instance_id=instId, **k_v)
            metadata = meta.filter(k_v.keys())
        except Exception as e:
            sys.stderr.write("Error: %s\n" % e)
            return 1
    else:
        # get
        if args.value_only:
            if len(args.keys) != 1:
                sys.stderr.write("Error: --value-only option works only with one -g or --get option. \n") 
                return 1
               
        try:
            meta = oci_utils.metadata.metadata(instance_id=instId, debug=args.debug,
                                  get_public_ip=False)
            metadata = meta.filter(args.keys)
        except Exception as e:
            sys.stderr.write("Error: %s\n" % e)
            return 1

    if metadata is None:
        if args.keys:
            sys.stderr.write("Error: No matching metadata for '%s' found.\n" % ','.join(args.keys))
        elif args.setkeys:
            sys.stderr.write("Error: No matching metadata for '%s' found.\n" % ','.join(args.setkeys))
        else:
            sys.stderr.write("Error: No metadata found for instance (%s).\n" % instId)
        return 1
   
    
    if args.value_only:
        print_value_only(args.keys, metadata)
        return 0

    if args.export:
        export_keys(args.keys, metadata)
        return 0

    if args.trim:
        print_trimed_key_values(args.keys, metadata)
        return 0
    if args.json:
        print json.dumps(metadata,  default=dumper, indent=2)
        return 0
    else:
        pretty_print(metadata)
        return 0

sys.exit(main())
