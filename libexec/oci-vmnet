#!/usr/bin/env python2.7

# oci-utils
#
# Copyright (c) 2017, 2018 Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at http://oss.oracle.com/licenses/upl.

"""
Oracle Cloud Infrastructure utilities - one shot service that configures
networking for virtual machines
"""

import os
import sys
import time
import argparse
import logging
from logging.handlers import SysLogHandler
import oci_utils
import oci_utils.iscsiadm
import oci_utils.kvm.nic
import oci_utils.kvm.virt

__logger = logging.getLogger('oci-vmnet')
__log_level = logging.INFO

__virtual_functions = 16

def setup_logging(syslog=False):
    global __logger
    global __log_level
    if syslog:
        handler = SysLogHandler(address='/dev/log',
                                facility=SysLogHandler.LOG_DAEMON)
    else:
        handler = logging.StreamHandler(stream=sys.stderr)
    handler.setLevel(__log_level)
    formatter = logging.Formatter('%(name)s - %(levelname)s '
                                  '- %(message)s')
    handler.setFormatter(formatter)
    __logger.setLevel(__log_level)
    __logger.addHandler(handler)

def parse_args():
    '''
    Parse the command line arguments and return an object representing the
    command line (as returned by argparse's parse_args())
    '''
    parser = argparse.ArgumentParser(description='oci-utils daemon')
    parser.add_argument('--debug', action='store_true',
                        help='display diagnostic output'),

    args = parser.parse_args()
    return args

def create_virtual_functions():
    # Find all interfaces that support sr-iov and imbue them with virtual functions.
    interfaces = oci_utils.kvm.nic.get_interfaces()
    for iface in interfaces:
        # Check to see if there are more than zero existing
        # virtual functions
        try:
            with open('/sys/class/net/{}/device/sriov_numvfs'.format(iface), 'r') as f:
                if 0 != int(f.read()):
                    continue
        except IOError:
            # If this file cannot be accessed for any reason, assume it is not
            # a PCI device
            continue

        # Create the virtual functions
        with open('/sys/class/net/{}/device/sriov_numvfs'.format(iface), 'w') as f:
            f.write(str(__virtual_functions))

    return 0

def wait_for_virtual_functions():
    interfaces = oci_utils.kvm.nic.get_interfaces()

    # Wait for all vfs to be instantiated
    vf_map = {}
    for iface in interfaces:
        try:
            with open('/sys/class/net/{}/devices/sriov_numvfs', 'r') as f:
                vf_map[iface] = int(f.read())
        except IOError:
            # If it's not possible to configure the virtual functions for
            # an interface, then it's not necessary to worry about them
            # changing
            continue

    for iface, vfs in vf_map.iteritems():
        while True:
            interfaces = oci_utils.kvm.nic.get_interfaces()
            if len(interfaces[iface]['virtfns']) == vfs:
                # Once all vfs are present, move on to the next
                # interface
                break

    # At this point, all vfs have been instantiated.  This does not mean that
    # udevd has had time to apply the appropriate device names.  By default,
    # all interfaces are going to be created as ethX and then mapped to a less
    # useless device name.  To keep things simple while maintaining a good
    # level of robustness, just wait for there to be no devices named 'eth' something.
    while True:
        dirs = os.listdir('/sys/class/net')
        done = True
        for d in dirs:
            if d.startswith('eth'):
                done = False
                break
        if not done:
            time.sleep(.5)
        else:
            break

def upgrade_v1_domains():
    vnics = oci_utils.metadata(get_public_ip=False).filter('vnics')['vnics']
    nics = oci_utils.kvm.nic.get_interfaces()
    domains = oci_utils.kvm.virt.get_domains_no_libvirtd()
    domain_xml = {d: oci_utils.kvm.virt.get_domain_xml_no_libvirtd(d) for d in domains}
    domain_interfaces = {d: oci_utils.kvm.virt.get_interfaces_from_domain(domain_xml[d]) for d in domains}

    # Find all domains that still use the v1.0 networking model and naming standard.
    # These domains need to be modified to use the v1.1 naming convention, and the supporting
    # network configuration must be written and brought up.
    config = {}
    for domain, ifaces in domain_interfaces.iteritems():
        interface_updates = {}
        for mac, name in ifaces.iteritems():
            if not name.startswith('vlan'):
                continue

            # Find a free vf to assign
            vnic = oci_utils.kvm.virt.find_vnic_by_mac(mac, vnics)
            phys_nic = oci_utils.kvm.virt.get_phys_by_index(vnic, vnics, nics)
            vf_pci_id, vf_num = oci_utils.kvm.virt.find_unassigned_vf_by_phys(phys_nic, domain_interfaces, mac)
            vf_dev = oci_utils.kvm.virt.get_interface_by_pci_id(vf_pci_id, nics)

            vf_cfg = oci_utils.kvm.sysconfig.make_vf(vf_dev, mac)
            vlan_cfg = oci_utils.kvm.sysconfig.make_vlan(vf_dev, vnic['vlanTag'])

            # Collect this configuration to write to the filesystem after the loop
            config[vf_cfg[0]] = vf_cfg[1]
            config[vlan_cfg[0]] = vlan_cfg[1]

            # Cache the new interface name.  These changes are applied
            # after this loop
            interface_updates[mac] = vlan_cfg[0]

        if len(interface_updates) > 0:
            oci_utils.kvm.virt.update_interfaces_for_domain(domain_xml[domain], interface_updates)
            oci_utils.kvm.virt.save_domain_xml(domain, domain_xml[domain])

    oci_utils.kvm.sysconfig.write_network_config(config)

def start_networking():
    domains = oci_utils.kvm.virt.get_domains_no_libvirtd()
    domain_xml = {d: oci_utils.kvm.virt.get_domain_xml_no_libvirtd(d) for d in domains}
    domain_interfaces = {d: oci_utils.kvm.virt.get_interfaces_from_domain(domain_xml[d]) for d in domains}

    # Gather all the interfaces that need to be brought up.  This includes all
    # interfaces for defined domains and all the intermediate plumbing interfaces.
    vlan_ifaces = []
    for d in domains:
        ifaces = domain_interfaces[d]
        for i in ifaces.values():
            try:
                # The only interface listed in the domain is the vlan
                # interface.  However, the interface for the VF that
                # supports the vlan must come up as well.  The vlan
                # interface name is <vf_name>.<tag>, so take everything
                # before the dot.
                vf, tag = i.split('.')
                vlan_ifaces.append(vf)
                vlan_ifaces.append(i)
            except:
                pass

    oci_utils.kvm.sysconfig.interfaces_up(vlan_ifaces)

def main(args):
    """
    Main program
    """
    create_virtual_functions()
    wait_for_virtual_functions()
    upgrade_v1_domains()
    start_networking()
    return 0

if os.geteuid() != 0:
    sys.stderr.write("This program must be run as root.\n")
    sys.exit(1)

args = parse_args()

oci_utils.iscsiadm.set_logger(__logger)

if args.debug:
    __log_level = logging.DEBUG

setup_logging(syslog=False)
sys.exit(main(args))
