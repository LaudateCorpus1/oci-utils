#!/usr/bin/env python2.7

# oci-utils
#
# Copyright (c) 2017, 2018 Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at http://oss.oracle.com/licenses/upl.

"""
Oracle Cloud Infrastructure utilities - daemon that polls for iscsi
and network configuration changes.
"""

import os
import sys
import time
import socket
import threading
import daemon
import daemon.pidfile
import sdnotify
import json
import argparse
import logging
from datetime import datetime, timedelta
from logging.handlers import SysLogHandler
import lockfile
import oci_utils
import oci_utils.iscsiadm
import oci_utils.metadata
import subprocess
from oci_utils.cache import load_cache, write_cache, get_timestamp
import oci_utils.oci_api
from oci_utils.exceptions import OCISDKError
from oci_utils.packages.stun import get_ip_info

__ocid_logger = logging.getLogger('ocid')
__log_level = logging.INFO

def setup_logging(syslog=False, debug=False):
    """
    Set up global logger __ocid_logger
    """
    global __ocid_logger
    global __log_level

    if debug:
        __log_level = logging.DEBUG

    if syslog:
        handler = SysLogHandler(address='/dev/log',
                                facility=SysLogHandler.LOG_DAEMON)
    else:
        handler = logging.StreamHandler(stream=sys.stderr)
    handler.setLevel(__log_level)
    formatter = logging.Formatter('%(name)s - %(levelname)s '
                                  '- %(message)s')
    handler.setFormatter(formatter)
    __ocid_logger.setLevel(__log_level)
    __ocid_logger.addHandler(handler)
    __ocid_logger.info('oci daemon starting')


def parse_args():
    '''
    Parse the command line arguments and return an object representing the
    command line (as returned by argparse's parse_args())
    '''
    parser = argparse.ArgumentParser(description='oci-utils daemon')
    parser.add_argument('--refresh', nargs='?', action='store',
                        metavar='FUNC', default=False,
                        help='refresh cached data for the given function, '
                        'or all functions if FUNC is not specified, and exit. '
                        'Possible values for FUNC: vnic, iscsi, '
                        'public_ip')
    parser.add_argument('--no-daemon', action='store_true',
                        help='run ocid in the foreground, useful for debugging')
    parser.add_argument('--debug', action='store_true',
                        help=argparse.SUPPRESS),
    parser.add_argument('--test', action='store_true', help=argparse.SUPPRESS)

    args = parser.parse_args()
    # when no argument is given set to True
    if args.refresh is None:
        args.refresh = True
    elif args.refresh:
        # not False and not None
        if args.refresh not in ['vnic', 'iscsi', 'public_ip']:
            sys.stderr.write('Invalid choice for --refresh\n')
            sys.exit(1)
    cfg = oci_utils.read_config()
    try:
        TRUE = ['true', 'True', 'TRUE']
        dbg = cfg.get('ocid', 'debug') in TRUE
        if dbg:
            args.debug = True
    except:
        pass
    return args

class ocidThread(threading.Thread):
    def __init__(self, name, ocidfunc, context, sleeptime, repeat=True):
        """
        creates a new ocid thread with the given name.
        The thread will execute the given ocidfunc function with the given
        context as the argument in an infinite loop.
        Sleep for sleeptime seconds after each iteration.
        ocidfunc must return a new context, which is passed to ocidfunc
        in the next iteration.
        """
        threading.Thread.__init__(self)
        self.thread_name = name
        self.ocidfunc = ocidfunc
        self.context = context
        self.debug = False
        if sleeptime < 1:
            self.sleeptime = 1
        else:
            try:
                self.sleeptime = int(sleeptime)
            except:
                self.sleeptime = 60
        self.repeat = repeat
        self.active = False
        self.first_iter_done = False
        self.threadLock = threading.Lock()

    def __str__(self):
        return self.thread_name

    def getName(self):
        return self.thread_name

    def set_debug(self, val):
        self.debug = val

    def stop(self):
        """
        Tell the thread to stop
        """
        # de-activate
        self.active = False

    def getContext(self):
        # make sure it's not running
        self.threadLock.acquire()
        # save context
        ctx = self.context
        self.threadLock.release()
        return ctx

    def setLogger(self, logger):
        self.logger = logger

    def is_first_iter_done(self):
        return self.first_iter_done

    def run(self):
        self.active = True
        self.logger.info("Starting ocid thread '%s'" % self.thread_name)
        while True:
            self.logger.debug("Running thread func for thread %s" % \
                              self.thread_name)
            self.threadLock.acquire()
            if not self.active:
                # shutting down.
                self.threadLock.release()
                sys.exit(0)
            try:
                self.context = self.ocidfunc(self.context)
            except Exception as e:
                self.logger.error("Error running ocid thread '%s': %s" % \
                                    (self.thread_name, e))
                if self.debug:
                    self.logger.exception(e)
            self.threadLock.release()
            # ocidfunc completed at least once
            self.first_iter_done = True
            if not self.repeat:
                # run the main function once only
                break
            time_slept = 0
            # sleep sleep_unit sec at a time so we can shut down cleanly in
            # no more than that time
            sleep_unit = 10
            while time_slept < self.sleeptime:
                if self.sleeptime - time_slept < sleep_unit:
                    time.sleep(self.sleeptime - time_slept)
                    time_slept = self.sleeptime
                else:
                    time.sleep(sleep_unit)
                    time_slept += sleep_unit
                if not self.active:
                    # shutting down
                    sys.exit(0)


def test_func(context):
    """
    ocid thread function for testing purposes.
    context is a dict.  returns a new context dict.
    """
    if not 'fname' in context:
        raise ValueError("fname must be defined in the context")
    if not 'counter' in context:
        raise ValueError("counter must be defined in the context")
    with open(context['fname'], "w+") as f:
        f.write("hello %d\n" % context['counter'])
    context['counter'] += 1
    return context


def public_ip_func(context):
    """
    ocid thread function for refreshing the instance metadata.
    """
    external_ip = oci_utils.metadata.metadata(get_public_ip=True).\
                get_public_ip(refresh=True)
    return {'publicIp': external_ip}


def iscsi_func(context):
    """
    ocid thread function for discovering and attaching/detaching
    block volumes.
    context must include 'max_volumes' and 'auto_detach'
    """
    if 'oci_sess' not in context:
        oci_sess = None
        if oci_utils.oci_api.HAVE_OCI_SDK:
            try:
                oci_sess = oci_utils.oci_api.OCISession()
            except:
                pass
        max_volumes = 8
        try:
            max_volumes = int(context['max_volumes'])
        except:
            pass
        auto_detach = True
        try:
            auto_detach = context['auto_detach']
        except:
            pass
        # the number of iterations to wait before detaching an offline volume
        detach_retry = 5
        try:
            detach_retry = int(context['detach_retry'])
        except:
            pass
        if max_volumes > oci_utils.oci_api.MAX_VOLUMES_LIMIT:
            __ocid_logger.warn("Your configured max_volumes(%s) is over the limit(%s)\n"
                         % (max_volumes,  oci_utils.oci_api.MAX_VOLUMES_LIMIT))
            max_volumes = oci_utils.oci_api.MAX_VOLUMES_LIMIT
        context = {'ignore_file_ts': 0,
                   'ignore_iqns': [],
                   'attach_failed': {},
                   'chap_pw_ts': 0,
                   'chap_pws': {},
                   'oci_sess': oci_sess,
                   'max_volumes': max_volumes,
                   'offline_vols': {},
                   'auto_detach': auto_detach,
                   'detach_retry': detach_retry,
                  }

    # devices currently attached
    session_devs = oci_utils.iscsiadm.session()

    # Load the saved passwords
    chap_passwords = context['chap_pws']
    if context['chap_pw_ts'] == 0 or \
       get_timestamp(oci_utils.__chap_password_file) > context['chap_pw_ts']:
        # the password file has changed or was never loaded
        context['chap_pw_ts'], chap_passwords = \
            load_cache(oci_utils.__chap_password_file)
    if chap_passwords is None:
        chap_passwords = {}
    # save for the next iteration
    context['chap_pws'] = chap_passwords

    # volumes that are offline in this iteration
    new_offline_vols = {}

    all_iqns = {}

    # volumes connected to this instance
    inst_volumes = []
    if context['oci_sess'] is not None:
        # get a list of volumes attached to the instance
        volumes = context['oci_sess'].this_instance().all_volumes(refresh=True)
        for v in volumes:
            vol = {'iqn': v.get_iqn(),
                   'ipaddr': v.get_portal_ip(),
                   'user': v.get_user(),
                   'password': v.get_password()}
            inst_volumes.append(vol)
            if v.get_portal_ip() in all_iqns:
                all_iqns[v.get_portal_ip()].append(v.get_iqn())
            else:
                all_iqns[v.get_portal_ip()] = [v.get_iqn()]
    else:
        # fall back to scanning
        for r in range(context['max_volumes'] + 1):
            ipaddr = "169.254.2.%d" % (r+1)
            iqns = oci_utils.iscsiadm.discovery(ipaddr)
            all_iqns[ipaddr] = iqns
            for iqn in iqns:
                vol = {'iqn': iqn,
                       'ipaddr': ipaddr,
                       'user': None,
                       'password': None}
                # look for a saved password
                if iqn in chap_passwords:
                    vol['user'] = chap_passwords[iqn][0]
                    vol['password'] = chap_passwords[iqn][1]
                inst_volumes.append(vol)

    # Load the list of volumes that were detached using oci-iscsi-config.
    # ocid shouldn't attach these automatically.
    ignore_iqns = context['ignore_iqns']
    if context['ignore_file_ts'] == 0 or \
       get_timestamp(oci_utils.__ignore_file) > context['ignore_file_ts']:
        # the list of detached volumes changed since last reading the file
        context['ignore_file_ts'], ignore_iqns = \
            load_cache(oci_utils.__ignore_file)
    if ignore_iqns is None:
        ignore_iqns = []
    # save for next iteration
    context['ignore_iqns'] = ignore_iqns

    # volumes that failed to attach in an earlier iteration
    attach_failed = context['attach_failed']

    # do we need to cache files?
    cache_changed = False
    ign_changed = False
    chap_changed = False

    # check if all discovered iscsi devices are configured and attached
    for vol in inst_volumes:
        if vol['iqn'] in ignore_iqns:
            # a device that was manually detached, so don't
            # re-attach it automatically
            continue
        if vol['iqn'] not in session_devs:
            if vol['iqn'] in attach_failed:
                # previous attempt to attach failed, ignore
                continue
            cache_changed = True
            # configure and attach the device
            __ocid_logger.info("Attaching iscsi device: %s:%s (%s)" % \
                               (vol['ipaddr'], "3260", vol['iqn']))
            if vol['user'] is not None:
                attach_result = \
                    oci_utils.iscsiadm.attach(vol['ipaddr'], 3260,
                                              vol['iqn'], vol['user'],
                                              vol['password'],
                                              auto_startup=True)
                if vol['iqn'] not in chap_passwords:
                    chap_passwords[vol['iqn']] = (vol['user'], vol['password'])
                    chap_changed = True
            else:
                attach_result = \
                    oci_utils.iscsiadm.attach(vol['ipaddr'], 3260,
                                              vol['iqn'],
                                              auto_startup=True)
            if attach_result != 0:
                __ocid_logger.info("Failed to attach device: %s" % \
                    oci_utils.iscsiadm.error_message_from_code(attach_result))
                attach_failed[vol['iqn']] = attach_result
                cache_changed = True

    # look for perviously failed volumes that are now in the session
    # (e.g. the user supplied the password using oci-iscsi-config)
    for iqn in attach_failed.keys():
        if iqn in session_devs:
            del attach_failed[iqn]
            cache_changed = True

    detach_retry = 5
    try:
        detach_retry = int(context['detach_retry'])
    except:
        pass

    # look for disconnected devices in the current session
    # these devices were disconnected from the instance in the console,
    # we now have to detach them from at the OS level
    for iqn in session_devs:
        # ignore the boot device
        if iqn.endswith('boot:uefi'):
            continue
        if not 'state' in session_devs[iqn]:
            continue
        if session_devs[iqn]['state'] in ['blocked', 'transport-offline']:
            __ocid_logger.debug("Checking iqn %s (state %s)\n" % \
                                (iqn, session_devs[iqn]['state']))
            # is the iqn discoverable at the portal?
            if iqn not in inst_volumes:
                # Not found by iscsiadm discovery.
                # To allow time for the volume to recover, wait for detach_retry
                # iterations where the volume was offline before detaching it
                if iqn not in context['offline_vols']:
                    __ocid_logger.info("iSCSI volume appears to be offline: " \
                                       "%s" % iqn)
                    new_offline_vols[iqn] = 1
                    continue
                elif context['offline_vols'][iqn] < detach_retry:
                    new_offline_vols[iqn] = context['offline_vols'][iqn] + 1
                    __ocid_logger.info("iSCSI volume still offline (%d): " \
                                       "%s" % (new_offline_vols[iqn], iqn))
                    continue

                if not context['auto_detach']:
                    __ocid_logger.info("Volume still offline, but iSCSI " \
                                       "auto_detach disabled: " \
                                       "%s" % iqn)
                    new_offline_vols[iqn] = detach_retry + 1
                    continue
                
                cache_changed = True
                ipaddr = session_devs[iqn]['persistent_portal_ip']
                __ocid_logger.info("Detaching iSCSI device: %s:%s (%s)" % \
                                   (ipaddr, "3260", iqn))
                oci_utils.iscsiadm.detach(ipaddr, 3260, iqn)
                # delete from list of previously offline volumes so it
                # doesn't get reported as 'now online'
                del context['offline_vols'][iqn]
                # device is gone, remove from "ignore" list
                if iqn in ignore_iqns:
                    ignore_iqns.remove(iqn)
                    ign_changed = True
                # remove from attach_failed list if present
                if iqn in attach_failed:
                    del attach_failed[iqn]
                    cache_changed = True

    # look for deviced that were previously offline but now back online
    # (just for printing a message that it's now online)
    for iqn in context['offline_vols']:
        if iqn not in new_offline_vols:
            __ocid_logger.info("iSCSI volume now online: %s" % iqn)
    context['offline_vols'] = new_offline_vols

    # check if the devices that were previously manually detached are still
    # connected to the instance
    inst_iqns = [vol['iqn'] for vol in inst_volumes]
    for iqn in ignore_iqns:
        if iqn not in inst_iqns:
            __ocid_logger.debug("Removing iqn %s from ignore list" % iqn)
            ignore_iqns.remove(iqn)
            ign_changed = True

    # rewrite changed cache files
    if ign_changed:
        context['ignore_file_ts'] = \
            write_cache(cache_content=ignore_iqns,
                        cache_fname=oci_utils.__ignore_file)
    if chap_changed:
        context['chap_pw_ts'] = \
            write_cache(cache_content=chap_passwords,
                        cache_fname=oci_utils.__chap_password_file,
                        mode=0o600)
    if cache_changed or not os.path.exists(oci_utils.iscsiadm.ISCSIADM_CACHE):
        write_cache(cache_content=[all_iqns, attach_failed],
                    cache_fname=oci_utils.iscsiadm.ISCSIADM_CACHE)
    else:
        try:
            os.utime(oci_utils.iscsiadm.ISCSIADM_CACHE, None)
        except Exception as e:
            __ocid_logger.warn("Failed to update cache timestamp: %s" % e)

    return context


def get_metadata_vnics():
    vnics = oci_utils.metadata.metadata(get_public_ip=False).filter('vnics')
    if vnics is not None and 'vnics' in vnics:
        # deep copy
        vnics_copy = [dict(x) for x in vnics['vnics']]
    else:
        vnics_copy = []

    return vnics_copy

def vnic_func(context):
    """
    ocid thread function to track vnic configuration changes
    context: {'vnic_utils': None, 'debug':debug, 'vf_net':vf_net}
    """
    if context['vf_net']:
        # Don't do any network configuration if something
        # else is doing it
        return context

    if context['vnic_utils'] is None:
        # first iteration
        oci_sess = None
        if oci_utils.oci_api.HAVE_OCI_SDK:
            try:
                oci_sess = oci_utils.oci_api.OCISession()
            except:
                pass
        context['oci_sess'] = oci_sess
        context['vnic_utils'] = oci_utils.VNICUtils(logger=__ocid_logger,
                                                    debug=context['debug'])
        context['vnic_info_ts'], context['vnic_info'] = \
            context['vnic_utils'].get_vnic_info()
        context['vnics'] = get_metadata_vnics()
        (ret, out) = context['vnic_utils'].auto_config([], False, False)
        if ret != 0:
            __ocid_logger.warning("Failed to configure network interfaces")
        if out is not None and out != "":
            __ocid_logger.info("secondary VNIC script reports: %s" % out)
        return context

    # If the vnic_info file changed then oci-network-config was invoked
    # and made changes.  We have to avoid undoing those changes.  Rebuild
    # the context instead.
    if oci_utils.VNICUtils.get_vnic_info_timestamp() > \
       context['vnic_info_ts']:
        __ocid_logger.debug("vnic_info file changed, rebuilding context")
        context['vnic_info_ts'], context['vnic_info'] = \
            context['vnic_utils'].get_vnic_info()
        context['vnics'] = get_metadata_vnics()
        return context

    vnics = get_metadata_vnics()

    update_needed = False

    if vnics != context['vnics']:
        # VNIC configuration changed
        __ocid_logger.info("VNIC configuration changed.")
        update_needed = True
        context['vnics'] = vnics

    if context['oci_sess'] is not None:
        # look for new or removed secondary private IP addresses
        p_ips = context['oci_sess'].this_instance().\
                all_private_ips(refresh=True)
        sec_priv_ip = \
            [[ip.get_address(), ip.get_vnic_ocid()] for ip in p_ips]
        for ip in sec_priv_ip:
            if ip not in context['vnic_info']['sec_priv_ip']:
                __ocid_logger.info("New secondary private IP: %s" % \
                                   ip[0])
                update_needed = True
        for ip in context['vnic_info']['sec_priv_ip']:
            if ip not in sec_priv_ip:
                __ocid_logger.info("Secondary private IP disconnected: %s" % \
                                   ip[0])
                update_needed = True
        if update_needed:
            # this one is used for comparing with the previous iteration
            context['vnic_info']['sec_priv_ip'] = sec_priv_ip
            context['vnic_utils'].set_private_ips(sec_priv_ip)

    if update_needed:
        __ocid_logger.info("updating network interfaces")
        (ret, out) = context['vnic_utils'].auto_config([], False, False)
        if ret != 0:
            __ocid_logger.warning("Failed to configure network interfaces")
        if out is not None and out != "":
            __ocid_logger.info("secondary VNIC script reports: %s" % out)

    return context


def start_thread(name, repeat, debug=False):
    """
    Start a specific thread, set it on repeat if repeat==True
    Return the thread object.
    """
    th = None
    cfg = oci_utils.read_config()
    TRUE = ['true', 'True', 'TRUE']
    if name == 'test':
        __log_level = logging.DEBUG
        th = ocidThread(name=name,
                        ocidfunc=test_func,
                        context={'fname':'/tmp/ocid-test', 'counter':1},
                        sleeptime=10,
                        repeat=repeat)
    elif name == 'public_ip':
        is_enabled = cfg.get('public_ip', 'enabled')
        if is_enabled not in TRUE:
            return None
        refresh_interval = cfg.get('public_ip', 'refresh_interval')
        th = ocidThread(name=name,
                        ocidfunc=public_ip_func,
                        context={},
                        sleeptime=refresh_interval,
                        repeat=repeat)
    elif name == 'iscsi':
        max_volumes = cfg.get('iscsi', 'max_volumes')
        is_enabled = cfg.get('iscsi', 'enabled')
        auto_detach = cfg.get('iscsi', 'auto_detach') in TRUE
        if is_enabled not in TRUE:
            return None
        #oci-growfs
        auto_resize = cfg.get('iscsi', 'auto_resize')
        if auto_resize in TRUE:
            try:
                output = subprocess.check_output(['/usr/libexec/oci-growfs',
                    '-y'], stderr=subprocess.STDOUT)
            except:
                pass

        scan_interval = cfg.get('iscsi', 'scan_interval')
        th = ocidThread(name=name,
                        ocidfunc=iscsi_func,
                        context={'max_volumes':max_volumes,
                                 'auto_detach':auto_detach,
                        },
                        sleeptime=scan_interval,
                        repeat=repeat)
    elif name == 'vnic':
        is_enabled = cfg.get('vnic', 'enabled')
        if is_enabled not in TRUE:
            return None
        scan_interval = cfg.get('vnic', 'scan_interval')
        vf_net = cfg.get('vnic', 'vf_net') in TRUE
        th = ocidThread(name=name,
                        ocidfunc=vnic_func,
                        context={'vnic_utils':None, 'debug':debug,
                                 'vf_net':vf_net},
                        sleeptime=scan_interval,
                        repeat=repeat)
    else:
        __ocid_logger.error('Internal error: unknown thread: %s' % name)
        return None
    th.setLogger(__ocid_logger)
    th.start()
    th.set_debug(debug)
    return th


def start_threads(args, repeat):
    """
    Start all threads according to the configuration or args.refresh.
    Set them on repeat if repeat==True.
    Return a dict of {thread_name: thread}
    """
    # set up threads
    threads = {}

    if args.test:
        # start the test thread
        th = start_thread('test', repeat, args.debug)
        if th:
            threads['test'] = th
    if not args.refresh or args.refresh == True:
        # is not a refresh request or is a request to refresh all
        # so start all threads
        th = start_thread('public_ip', repeat, args.debug)
        if th:
            threads['public_ip'] = th
        th = start_thread('iscsi', repeat, args.debug)
        if th:
            threads['iscsi'] = th
        th = start_thread('vnic', repeat, args.debug)
        if th:
            threads['vnic'] = th
    elif args.refresh:
        # start a specific thread only
        th = start_thread(args.refresh, repeat, args.debug)
        if th:
            threads[args.refresh] = th
        return threads

    return threads


def monitor_threads(threads, args):
    try:
        # exit and let systemd restart the process to avoid issues with
        # potential memory leaks
        time.sleep(60*60*2)
    except:
        # the sleep was interrupted
        pass

    for th in threads.keys():
        threads[th].stop()

    # give up to 30 seconds for threads to exit cleanly
    timeout = datetime.now() + timedelta(seconds=30)
    while timeout > datetime.now():
        thread_running = False
        for th in threads.keys():
            if threads[th].is_alive():
                thread_running = True
        if not thread_running:
            break
    return 0


def wait_for_threads(threads):
    for th in threads.keys():
        threads[th].join()
        __ocid_logger.debug('Thread %s finished.' % th)
    return 0


def daemon_main(args):
    if args.no_daemon:
        setup_logging(syslog=False, debug=args.debug)
    else:
        setup_logging(syslog=True, debug=args.debug)

    oci_utils.iscsiadm.set_logger(__ocid_logger)

    if args.refresh:
        # run the selected threads once
        threads = start_threads(args, repeat=False)
        result = wait_for_threads(threads)
        sys.exit(result)

    threads = start_threads(args, repeat=True)

    # wait for every thread to complete the ocid func at least once
    first_iter_done = False
    while not first_iter_done:
        first_iter_done = True
        for th in threads.keys():
            if not threads[th].is_first_iter_done():
                # not finished yet
                first_iter_done = False
                __ocid_logger.debug('waiting for thread %s to finish the '
                                    'first iteration' % th)
                time.sleep(1)

    __ocid_logger.debug('all threads finished the first iteration')

    if args.no_daemon:
        os._exit(monitor_threads(threads, args))
    else:
        # Inform systemd that dependent services can now start
        notifier = sdnotify.SystemdNotifier()
        notifier.notify("READY=1")

    monitor_threads(threads, args)

def main():
    if os.geteuid() != 0:
        sys.stderr.write("This program must be run as root.\n")
        sys.exit(1)

    pidlock = daemon.pidfile.PIDLockFile('/var/run/ocid.pid')

    args = parse_args()

    if pidlock.is_locked():
        if not args.refresh:
            sys.stderr.write("ocid already running.\n")
            sys.exit(1)

    if args.no_daemon:
        daemon_main(args)
    else:
        daemon_context = daemon.DaemonContext(
            pidfile=pidlock,
            umask=0o033)
        with daemon_context:
            daemon_main(args)


try:
    main()
except Exception as e:
    print e

os._exit(0)
