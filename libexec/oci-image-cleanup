#!/bin/bash
      
# This script runs a set of cleanup steps to prepare instance for snapshot
     
  
# Globals
FORCE=false
BACKUP_LOC=/opt/image-cleanup-backup.$$

#cleanup configs
CLEAN_ETC_HOSTS=
CLEAN_NET_CONFIG_FILES=
CLEAN_HOST_SSH_KEYS=
CLEAN_ROOT_PASSWD=
CLEAN_USER_SSH_KEYS=
CLEAN_HISTORY_DADA_LOG=
  
# Print usage message
usage()
{
cat <<EOF
Usage: $0" [OPTION]
  
  -f [y|n]
  --force=[y|n]                No prompt for confirmation, use the value you provide as the answer.
                               "y" for cleanup all, "n" for dry run, delete nothing.
  -r <BACKUP_DIR>
  --restore=<BACKUP_DIR>       Restore files from BACKUP_DIR

  -d <BACKUP_DIR>
  --backup-dir=<BACKUP_DIR>    Specify dir to backup deleted files.
                               Default backup dir is /opt/image-cleanup-backup.<pid>
  -c <CONFIG_FILE>
  --config-file=<CONFIG_FILE>  Specify config file. 
                               Sample config file is /etc/oci-utils/oci-image-cleanup.conf.

  -h
  --help                       print this message.

This script runs a set of cleanup steps to prepare OCI OL instances for custom images
WARNING!!! This script will clear ssh keys and root passwd.
Upon execution of this script, if you choose to clear the ssh keys, you will no longer be able to login to
this instance with your existing credentials.
You will need to create a new custom image of this instance first and then create a new compute instance
from that custom image to login. More info on custom images can be found here:
     
https://docs.us-phoenix-1.oraclecloud.com/Content/Compute/Tasks/managingcustomimages.htm
 
EOF
}
     
# Prompt for action confirmation
confirm()
{
    while true
    do
        if [[ $FORCE = true ]]; then
            [[ $F_VALUE =~ ^[y|Y] ]] && return 0
            [[ $F_VALUE =~ ^[n|N] ]] && return 1
        fi
        [ $# -eq 1 ] && input=$1 ||read -r -p "Confirm? [y/n]: " input
     
        case $input in
            [yY][eE][sS]|[yY])
                return 0;;
     
            [nN][oO]|[nN])
                return 1;;
            *)
        esac
    done
}

print_and_exit()
{
  if [ $1 -eq 0 ]; then
    echo -e '\n*********************************************************************************************************************************'
    echo "Cleanup finished. All deleted files backed up at $BACKUP_LOC . Please review and delete at your own descretion"
    echo "In cause you change your mind, you can restore the cleaned up files by running: $0 -r $BACKUP_LOC"
  else
    echo -e '\n*********************************************************************************************************************************'
    echo "WARNING!!! Script may not have run completely. All deleted files backed up at $BACKUP_LOC ."
    echo "To restore the cleaned up files run: $0 -r $BACKUP_LOC"
  fi
  exit $1
}
  
backup_and_delete()
{
  if [ $# != 1 ]; then
    print_and_exit 1
  fi
  backup_item=$1
  echo -n "Clearing $backup_item..."
  backup_dir=$(dirname $1|head -1)
  [ ! -d $BACKUP_LOC/$backup_dir ] && mkdir -p $BACKUP_LOC/$backup_dir &>/dev/null
  mv $backup_item $BACKUP_LOC/$backup_dir/ &>/dev/null
  echo "Done!"
}
  
warn()
{
  echo -e "WARNING!!! This script will clear ssh keys and root passwd.
This means you will no longer be able to login to this instance.
Run: $(basename "$0") -h or man $(basename "$0") for more info"
      
  read -n 1 -s -r -p "Press any key to continue. Or Ctrl + c to exit"
}
  
mk_backup_dir()
{
  # Create backup dir
  mkdir -p $BACKUP_LOC &>/dev/null
  if [ $? -ne 0 ]; then
    echo "Unable to create backup folder $BACKUP_LOC . Exiting"
    exit 1
  fi
}
    
  
cleanup()
{
  [[ $FORCE == true ]] || warn
  mk_backup_dir
  trap 'print_and_exit 1' SIGINT
  echo -e "\n\nPreparing instance for OCI custom image. All deleted files will be backed up at $BACKUP_LOC"
  # Cleanup network config files
  echo "Deleting network config files... "
  for file in `find /etc/sysconfig/network-scripts/ -name "ifcfg-*" -not -name ifcfg-lo` ; do
      confirm $CLEAN_NET_CONFIG_FILES && backup_and_delete $file
  done
         
  # clear /etc/hosts
  echo "Deleting the contents of /etc/hosts and /etc/resolv.conf... "
  confirm $CLEAN_ETC_HOSTS
  if [ $? -eq 0 ]; then
  backup_and_delete "/etc/hosts"
  echo -e "127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6" > /etc/hosts
  # Scrub Resolv.conf
  echo "Scrubbing /etc/resolv.conf..."
  backup_and_delete "/etc/resolv.conf"
  :> /etc/resolv.conf
  fi
       
  # clear ssh keys
  echo "Deleting SSH host keys in /etc/ssh/ ...."
  confirm $CLEAN_HOST_SSH_KEYS && backup_and_delete "/etc/ssh/ssh_host*"
  for user in $(egrep '/bin/bash|/bin/sh' /etc/passwd|awk -F: '{print $6}' )
  do
      [ -d $user/.ssh ] &&  echo "Deleting SSH keys in $user/.ssh/ "
      confirm $CLEAN_USER_SSH_KEYS && backup_and_delete "$user/.ssh/*"
  done
       
       
  # Lock root account and clear root passwd
  echo "Locking root account and clearing root passwd... "
  confirm $CLEAN_ROOT_PASSWD
  if [ $? -eq 0 ]; then
      mkdir $BACKUP_LOC/etc/ &>/dev/null
      cp /etc/shadow $BACKUP_LOC/etc/
      passwd -l root && sed -i 's/^root:[^:]*:/root:*:/I' /etc/shadow
  fi 
  echo -e "The next steps will clean up the following files:
      /etc/udev/rules.d/70*, 
      /etc/ machine-id, 
      /var/logs/*, 
      /etc/chrony.key,  
      /var/cache/yum, 
      /tmp/*,
      /var/lib/dhclient/*, 
      /var/lib/random-seed, 
      /var/lib/systemd/random-seed, 
      /etc/lvm/cache/.cache, 
      /var/lib/yum/uuid,
      /var/lib/cloud/*, 
      /var/lib/iscsi/*, 
      /etc/sysconfig/rhn/systemid, 
      /etc/sysconfig/rhn/up2date,
      .bash_history
  "
      
  confirm $CLEAN_HISTORY_DATA_LOG || print_and_exit 1
  # Remove persistent network rules
  echo "Removing persistent network rules..."
  backup_and_delete "/etc/udev/rules.d/70*"
         
  # Scrub machine-id
  echo "Scrubbing /etc/machine-id..."
  backup_and_delete "/etc/machine-id"
  : > /etc/machine-id
        
  # Scrub Log Files
  echo "Scrubbing log files in /var/log..."
  for SCRUB_FILE in $(find /var/log/ -type f);
  do
      backup_and_delete $SCRUB_FILE
      : > $SCRUB_FILE;
  done
       
         
  # Scrub Chrony Cleanup
  echo "Scrubbing /etc/chrony.keys..."
  backup_and_delete "/etc/chrony.keys"
  : > /etc/chrony.keys
         
  # Clean tmp
  echo "Cleaning /tmp..."
  # Sorry tmp, no backup love for you
  rm -rf /tmp/*
         
  # Clean Leases
  echo "Removing dhcp lease files..."
  backup_and_delete "/var/lib/dhclient/*"
         
  # Clean starting seed
  echo "Cleaning starting seed..."
  backup_and_delete "/var/lib/random-seed"
  backup_and_delete "/var/lib/systemd/random-seed"
         
  # Clean LVM cache
  echo "Cleaning lvm cache..."
  backup_and_delete "/etc/lvm/cache/.cache"
         
  # Clean Yum UUID
  echo "Removing Yum UUID..."
  backup_and_delete "/var/lib/yum/uuid"
       
  # Cleaning up Yum metadata
  echo "Clean yum metadata..."
  yum clean all >/dev/null
  rm -rf /var/cache/yum
         
  # Purge cloud-init data
  echo "Clearing cloud-init data..."
  backup_and_delete "/var/lib/cloud/*"
       
  # Remove stale iscsi configuration data
  echo "Clearing stale iscsi configuration data..."
  backup_and_delete "/var/lib/iscsi/nodes/*"
  backup_and_delete "/var/lib/iscsi/send_targets/*"
  backup_and_delete "/var/lib/iscsi/ifaces/*"
         
  # Clear uln stuff
  echo "Clearing ULN data..."
  backup_and_delete "/etc/sysconfig/rhn/systemid"
  cp /etc/sysconfig/rhn/up2date $BACKUP_LOC/etc/sysconfig/rhn/
  sed -i  's/^uuid.*/#&/' /etc/sysconfig/rhn/up2date
       
  # Clear bash history for opc and root users
  echo "Cleaning bash history..."
  set -o history
  backup_and_delete "/home/opc/.bash_history" && ln -s -f /dev/null /home/opc/.bash_history
  update_bashrc_history /home/opc
  backup_and_delete "/root/.bash_history" && ln -s -f /dev/null /root/.bash_history
  update_bashrc_history /root
      
  
  print_and_exit 0
      
  # El Fin
  }
    
update_bashrc_history() {
  hist_file=$1/.bash_history

  grep bash_history $1/.bashrc >/dev/null 2>&1 && return 0
  echo -e " 
  [ -f $hist_file ] || rm -f $hist_file && touch $hist_file 
  " >>$1/.bashrc
  return 0
}
restore()
{
  backup_dir=$1
  cd $backup_dir
  echo  "Restoring all files from $backup_dir"
  echo  'If file to be restored already exists, it will be restored with a ~ suffix'
  confirm && tar -cvz .|tar --backup=simple -xvz -C /
  
}
  
# Main
  
if [ "$EUID" -ne 0 ]; then 
    echo "This script needs root privileges to execute."
    exit 1
fi
       
while [ "$#" -gt 0 ]; do
  case "$1" in
    -f)
        FORCE=true
        if [[ $2 =~ ^[y|Y|n|N]$ ]]; then
            F_VALUE=$2
            shift 2
        else
            echo -e '\nError: -f need a "y" or "n" after it.\n'
            usage
            exit 1
        fi
        ;;
    --force=*)
        FORCE=true
        F_VALUE=${1#*=}
        if [[ $F_VALUE =~ ^[y|Y|n|N]$ ]]; then
            shift 1
        else
            echo -e '\nError: --force should equal to a "y" or "n".\n'
            usage
            exit 1
        fi
        ;;
    -r)
        if [ -d $2 ] && [[ $2 =~ "image-cleanup-backup" ]] ; then
            restore $2; exit
        else
            echo -e '\n' ${2} 'does not appear to be a valid backup dir\n'
            usage
            exit 1
        fi
        ;;
    -c)
        if [ -f $2 ] && [ -s $2 ]; then
            source $2
            shift 2
        else
            echo  "Error: ${config_file} does not appear to be a valid file."
            usage
            exit 1
        fi
        ;;
    --config-file=*)
        config_file="${1#*=}"
        if [ -f $config_file ] && [ -s $config_file ] ; then
            source $config_file
            shift 1
        else
            echo  "Error: ${config_file} does not appear to be a valid file."
            usage
            exit 1
        fi
        ;;
    -d)
        if [ -d $2 ] && [ ! -z  $2 ] ;then
            BACKUP_LOC=$2/image-cleanup-backup.$$; shift 2
        else
            echo -e '\n' ${2} 'does not appear to be a valid backup dir\n'
            usage
            exit 1
        fi
        ;;
    --restore=*)
        restore_dir="${1#*=}"
        if [ -d $restore_dir ] && [[ $restore_dir =~ "image-cleanup-backup" ]] ; then
            restore $restore_dir; exit
        else
            echo -e '\n' ${2} 'does not appear to be a valid backup dir\n'
            usage
            exit 1
        fi
        ;;
    --backup-dir=*)
        backup_dir="${1#*=}"
        if [ -d $backup_dir ] && [ ! -z  $backup_dir ] ;then
            BACKUP_LOC=$backup_dir/image-cleanup-backup.$$; shift 1
        else
            echo -e '\n' $backup_dir 'does not appear to be a valid backup dir\n'
            usage
            exit 1
        fi
        ;;
    -h | --help)
        usage
        exit 0
        ;;

    -* | *) 
        echo "unknown option: $1" >&2;  usage; exit 1;;
    esac
done
 
cleanup

